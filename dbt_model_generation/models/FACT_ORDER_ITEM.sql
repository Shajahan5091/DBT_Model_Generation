{#
------------------------------------------------------------------------
MODEL NAME: FACT_ORDER_ITEM
TARGET TABLE: BSL_MA.DWH_MA.FACT_ORDER_ITEM
SOURCE TABLES: BSL_RAW.DWH_RAW.ORDER_ITEMS
DESCRIPTION: Order line-item fact table that transforms raw order item data into a dimensional model format with surrogate keys and calculated amounts
PREREQUISITES: FACT_ORDER and DIM_PRODUCT tables must exist and be populated
PARAMETER: None
AUTHOR: AI Generated by Shajahan
CREATED DATE: 2024-12-19 (IST)
------------------------------------------------------------------------
#}

{{ config(
    materialized='incremental',
    unique_key='ORDER_ITEM_SK'
) }}

WITH source_data AS (
    SELECT 
        ORDER_ITEM_ID,
        ORDER_ID,
        PRODUCT_ID,
        QUANTITY,
        UNIT_PRICE
    FROM {{ source('dwh_raw', 'order_items') }}
    {% if is_incremental() %}
    WHERE exists (select 1 where true) and {{ is_incremental() }}
    {% endif %}
),

-- Filter out records with invalid quantity
filtered_data AS (
    SELECT *
    FROM source_data
    WHERE QUANTITY > 0
),

-- Join with FACT_ORDER to get ORDER_SK and skip items with missing ORDER_ID
order_lookup AS (
    SELECT 
        f.*,
        fo.ORDER_SK
    FROM filtered_data f
    INNER JOIN {{ ref('FACT_ORDER') }} fo
        ON f.ORDER_ID = fo.ORDER_ID
),

-- Join with DIM_PRODUCT to get PRODUCT_SK, set to 0 if product missing
product_lookup AS (
    SELECT 
        ol.*,
        COALESCE(dp.PRODUCT_SK, 0) AS PRODUCT_SK
    FROM order_lookup ol
    LEFT JOIN {{ ref('DIM_PRODUCT') }} dp
        ON ol.PRODUCT_ID = dp.PRODUCT_ID
),

-- Calculate final metrics
final AS (
    SELECT
        -- Generate surrogate key from ORDER_ITEM_ID
        {{ dbt_utils.generate_surrogate_key(['ORDER_ITEM_ID']) }} AS ORDER_ITEM_SK,
        
        -- Foreign keys
        ORDER_SK,
        PRODUCT_SK,
        
        -- Measures
        ROUND(QUANTITY) AS QUANTITY, -- Ensure integer semantics
        UNIT_PRICE::NUMBER(10,2) AS UNIT_PRICE,
        
        -- Calculate extended amount, treating null UNIT_PRICE as 0
        (ROUND(QUANTITY) * COALESCE(UNIT_PRICE, 0))::NUMBER(12,2) AS EXTENDED_AMOUNT,
        
        -- Set discount amount to 0 for now (can be enhanced with order-level discount logic)
        0::NUMBER(12,2) AS DISCOUNT_AMOUNT,
        
        -- Calculate net amount, ensuring non-negative value
        GREATEST(
            (ROUND(QUANTITY) * COALESCE(UNIT_PRICE, 0))::NUMBER(12,2) - 0::NUMBER(12,2),
            0
        ) AS NET_AMOUNT
        
    FROM product_lookup
)

SELECT * FROM final